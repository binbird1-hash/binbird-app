-- Initial BinBird schema
create extension if not exists "pgcrypto";

-- Utility trigger to keep updated_at columns in sync
create or replace function public.tg__set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := timezone('utc', now());
  return new;
end;
$$;

-- User profile table mirrors auth.users with extra metadata
create table if not exists public.user_profile (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text,
  name text,
  phone text,
  role text not null default 'staff',
  map_style_pref text not null default 'Dark',
  nav_pref text not null default 'google',
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger trg_user_profile_updated_at
before update on public.user_profile
for each row
execute function public.tg__set_updated_at();

alter table public.user_profile enable row level security;

create policy "Users select own profile"
  on public.user_profile
  for select
  using (auth.uid() = user_id or auth.role() = 'service_role');

create policy "Users update own profile"
  on public.user_profile
  for update
  using (auth.uid() = user_id or auth.role() = 'service_role')
  with check (auth.uid() = user_id or auth.role() = 'service_role');

create policy "Service role inserts profiles"
  on public.user_profile
  for insert
  with check (auth.role() = 'service_role');

-- Helper to seed user_profile when a new auth user registers
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.user_profile (user_id, email)
  values (new.id, new.email)
  on conflict (user_id) do update
    set email = excluded.email;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row
  execute function public.handle_new_user();

-- Expose the caller's role for middleware checks
create or replace function public.get_my_role()
returns text
language sql
security definer
set search_path = public
as $$
  select coalesce(
    (
      select role
      from public.user_profile
      where user_id = auth.uid()
    ),
    'staff'
  );
$$;

-- Convenience helpers for RLS predicates
create or replace function public.is_staff_or_admin()
returns boolean
language sql
security definer
set search_path = public
as $$
  select coalesce(
    (
      select role in ('staff', 'admin')
      from public.user_profile
      where user_id = auth.uid()
    ),
    false
  );
$$;

create or replace function public.is_admin()
returns boolean
language sql
security definer
set search_path = public
as $$
  select coalesce(
    (
      select role = 'admin'
      from public.user_profile
      where user_id = auth.uid()
    ),
    false
  );
$$;

-- Core business entities ----------------------------------------------------

create table if not exists public.client (
  id bigint generated by default as identity primary key,
  name text not null,
  contact_email text,
  contact_phone text,
  notes text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.client_token (
  id bigint generated by default as identity primary key,
  client_id bigint not null references public.client(id) on delete cascade,
  token text not null unique,
  expires_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger trg_client_updated_at
before update on public.client
for each row
execute function public.tg__set_updated_at();

create trigger trg_client_token_updated_at
before update on public.client_token
for each row
execute function public.tg__set_updated_at();

alter table public.client enable row level security;
alter table public.client_token enable row level security;

create policy "Staff manage client tokens"
  on public.client_token
  for all
  using (public.is_staff_or_admin() or auth.role() = 'service_role')
  with check (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Client portal read tokens"
  on public.client_token
  for select
  using (auth.role() in ('anon', 'service_role'));

create policy "Staff view clients"
  on public.client
  for select
  using (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Client portal read clients"
  on public.client
  for select
  using (
    auth.role() = 'anon'
    and exists (
      select 1
      from public.client_token ct
      where ct.client_id = public.client.id
    )
  );

create policy "Admin manage clients"
  on public.client
  for all
  using (public.is_admin() or auth.role() = 'service_role')
  with check (public.is_admin() or auth.role() = 'service_role');

create table if not exists public.property (
  id bigint generated by default as identity primary key,
  client_id bigint not null references public.client(id) on delete cascade,
  address text not null,
  lat double precision,
  lng double precision,
  bins text,
  notes text,
  photo_path text,
  assigned_to uuid references auth.users(id),
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger trg_property_updated_at
before update on public.property
for each row
execute function public.tg__set_updated_at();

alter table public.property enable row level security;

create policy "Staff view properties"
  on public.property
  for select
  using (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Client portal read properties"
  on public.property
  for select
  using (
    auth.role() = 'anon'
    and exists (
      select 1
      from public.client_token ct
      where ct.client_id = public.property.client_id
    )
  );

create policy "Admin manage properties"
  on public.property
  for all
  using (public.is_admin() or auth.role() = 'service_role')
  with check (public.is_admin() or auth.role() = 'service_role');

create table if not exists public.schedule (
  id bigint generated by default as identity primary key,
  property_id bigint not null references public.property(id) on delete cascade,
  out_weekdays smallint[] not null default array[]::smallint[],
  in_weekdays smallint[] not null default array[]::smallint[],
  assigned_to uuid references auth.users(id),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger trg_schedule_updated_at
before update on public.schedule
for each row
execute function public.tg__set_updated_at();

alter table public.schedule enable row level security;

create policy "Staff view schedules"
  on public.schedule
  for select
  using (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Admin manage schedules"
  on public.schedule
  for all
  using (public.is_admin() or auth.role() = 'service_role')
  with check (public.is_admin() or auth.role() = 'service_role');

create table if not exists public.job (
  id uuid primary key default gen_random_uuid(),
  property_id bigint not null references public.property(id) on delete cascade,
  kind text not null check (kind in ('IN', 'OUT')),
  scheduled_for date not null,
  assigned_to uuid references auth.users(id),
  last_completed_on date,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger trg_job_updated_at
before update on public.job
for each row
execute function public.tg__set_updated_at();

-- Default assignment mirrors schedule or property preferences
create or replace function public.apply_job_defaults()
returns trigger
language plpgsql
as $$
declare
  sched_assignee uuid;
  prop_assignee uuid;
begin
  if new.assigned_to is null then
    select s.assigned_to into sched_assignee
    from public.schedule s
    where s.property_id = new.property_id
    order by s.id desc
    limit 1;

    if sched_assignee is not null then
      new.assigned_to := sched_assignee;
    else
      select p.assigned_to into prop_assignee
      from public.property p
      where p.id = new.property_id;

      if prop_assignee is not null then
        new.assigned_to := prop_assignee;
      end if;
    end if;
  end if;

  return new;
end;
$$;

create trigger trg_job_defaults
before insert on public.job
for each row
execute function public.apply_job_defaults();

alter table public.job enable row level security;

create policy "Staff view jobs"
  on public.job
  for select
  using (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Staff insert jobs"
  on public.job
  for insert
  with check (public.is_staff_or_admin() or auth.role() = 'service_role');

create policy "Staff update jobs"
  on public.job
  for update
  using (public.is_staff_or_admin() or auth.role() = 'service_role')
  with check (public.is_staff_or_admin() or auth.role() = 'service_role');

create table if not exists public.logs (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id),
  client_name text,
  address text,
  task_type text,
  bins text,
  notes text,
  photo_path text,
  done_on date,
  gps_lat double precision,
  gps_lng double precision,
  gps_acc double precision,
  gps_time timestamptz,
  created_at timestamptz not null default timezone('utc', now())
);

alter table public.logs enable row level security;

create policy "Staff manage logs"
  on public.logs
  for all
  using (public.is_staff_or_admin() or auth.role() = 'service_role')
  with check (public.is_staff_or_admin() or auth.role() = 'service_role');

-- Reporting and helper views ------------------------------------------------

create or replace view public.client_list as
select
  c.id,
  c.name as client_name,
  c.created_at
from public.client c;

create or replace view public.client_list_view as
select
  c.name as client_name,
  p.address,
  coalesce(p.bins, '—') as bins_this_week
from public.property p
join public.client c on c.id = p.client_id
where p.is_active;

create or replace view public.jobs as
select
  j.id,
  p.address,
  p.lat,
  p.lng,
  j.last_completed_on,
  j.assigned_to,
  to_char(j.scheduled_for, 'FMDay') as day_of_week,
  p.photo_path,
  c.name as client_name,
  p.bins,
  p.notes,
  case when j.kind = 'IN' then 'bring_in' else 'put_out' end as job_type,
  j.scheduled_for
from public.job j
join public.property p on p.id = j.property_id
join public.client c on c.id = p.client_id;

create or replace function public.jobs_view_update()
returns trigger
language plpgsql
as $$
begin
  update public.job
  set last_completed_on = new.last_completed_on,
      assigned_to = new.assigned_to,
      updated_at = timezone('utc', now())
  where id = old.id;

  return new;
end;
$$;

drop trigger if exists trg_jobs_view_update on public.jobs;
create trigger trg_jobs_view_update
  instead of update on public.jobs
  for each row
  execute function public.jobs_view_update();

-- Storage bucket for run proofs ---------------------------------------------

do $$
begin
  if not exists (select 1 from storage.buckets where id = 'proofs') then
    perform storage.create_bucket('proofs', public := true);
  end if;

  update storage.buckets
    set public = true
    where id = 'proofs';
end;
$$;

alter table if exists storage.objects enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'storage'
      and tablename = 'objects'
      and policyname = 'Proofs public read'
  ) then
    create policy "Proofs public read"
      on storage.objects
      for select
      using (bucket_id = 'proofs');
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'storage'
      and tablename = 'objects'
      and policyname = 'Proofs staff upload'
  ) then
    create policy "Proofs staff upload"
      on storage.objects
      for insert
      with check (
        bucket_id = 'proofs'
        and (auth.role() = 'service_role' or public.is_staff_or_admin())
      );
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'storage'
      and tablename = 'objects'
      and policyname = 'Proofs staff update'
  ) then
    create policy "Proofs staff update"
      on storage.objects
      for update
      using (
        bucket_id = 'proofs'
        and (auth.role() = 'service_role' or public.is_staff_or_admin())
      )
      with check (
        bucket_id = 'proofs'
        and (auth.role() = 'service_role' or public.is_staff_or_admin())
      );
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'storage'
      and tablename = 'objects'
      and policyname = 'Proofs admin delete'
  ) then
    create policy "Proofs admin delete"
      on storage.objects
      for delete
      using (
        bucket_id = 'proofs'
        and (auth.role() = 'service_role' or public.is_admin())
      );
  end if;
end;
$$;
